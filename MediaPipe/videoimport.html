<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Video Processing with Logs</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            font-family: Arial, sans-serif;
        }
        #videoUpload {
            margin-top: 20px;
        }
        #uploadedVideo, #outputCanvas {
            width: 100%;
            max-width: 600px;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <input type="file" id="videoUpload" accept="video/*">
    <video id="uploadedVideo" controls></video>
    <canvas class="output_canvas" id="outputCanvas"></canvas>
    <br><br>
    <button id="downloadLogs">Télécharger les données</button>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/holistic/holistic.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>

    <script>
        // Assurez-vous que le script est chargé
        console.log('Script chargé');

        // Récupérer les éléments vidéo et canvas
        const videoElement = document.getElementsByClassName('input_video')[0];
        const canvasElement = document.getElementsByClassName('output_canvas')[0] || document.getElementById('outputCanvas');
        const canvasCtx = canvasElement.getContext('2d');

        // Variables pour stocker les logs et le nom de la vidéo
        let logs = [];
        let videoFileName = 'logs.txt';

        // Fonction pour télécharger les logs sous forme de fichier texte
        function downloadLogs() {
            const blob = new Blob(logs, { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = videoFileName.replace(/\.[^/.]+$/, "") + '.txt'; // Remplacer l'extension par .txt
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }

        // Fonction pour gérer les résultats
        function onResults(results) {
            // Convertir les résultats au format string
            const logData = JSON.stringify(results);
            logs.push(logData);

            // Afficher les résultats dans la console
            console.log('Résultats :', results);

            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

            // Dessiner le masque de segmentation
            if (results.segmentationMask) {
                canvasCtx.drawImage(results.segmentationMask, 0, 0, canvasElement.width, canvasElement.height);

                // Seulement écraser les pixels existants
                canvasCtx.globalCompositeOperation = 'source-in';
                canvasCtx.fillStyle = '#00FF00';
                canvasCtx.fillRect(0, 0, canvasElement.width, canvasElement.height);

                // Seulement écraser les pixels manquants
                canvasCtx.globalCompositeOperation = 'destination-atop';
                canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

                canvasCtx.globalCompositeOperation = 'source-over';
            }

            // Dessiner les landmarks de pose
            if (results.poseLandmarks) {
                drawConnectors(canvasCtx, results.poseLandmarks, POSE_CONNECTIONS, {color: '#00FF00', lineWidth: 4});
                drawLandmarks(canvasCtx, results.poseLandmarks, {color: '#FF0000', lineWidth: 2});
            }

            // Dessiner les landmarks du visage
            if (results.faceLandmarks) {
                drawConnectors(canvasCtx, results.faceLandmarks, FACEMESH_TESSELATION, {color: '#C0C0C070', lineWidth: 1});
            }

            // Dessiner les landmarks de la main gauche
            if (results.leftHandLandmarks) {
                drawConnectors(canvasCtx, results.leftHandLandmarks, HAND_CONNECTIONS, {color: '#CC0000', lineWidth: 5});
                drawLandmarks(canvasCtx, results.leftHandLandmarks, {color: '#00FF00', lineWidth: 2});
            }

            // Dessiner les landmarks de la main droite
            if (results.rightHandLandmarks) {
                drawConnectors(canvasCtx, results.rightHandLandmarks, HAND_CONNECTIONS, {color: '#00CC00', lineWidth: 5});
                drawLandmarks(canvasCtx, results.rightHandLandmarks, {color: '#FF0000', lineWidth: 2});
            }

            canvasCtx.restore();
        }

        // Initialiser Holistic
        const holistic = new Holistic({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/holistic/${file}`;
        }});
        holistic.setOptions({
            modelComplexity: 1,
            smoothLandmarks: true,
            enableSegmentation: true,
            smoothSegmentation: true,
            refineFaceLandmarks: true,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        holistic.onResults(onResults);

        // Gérer l'importation de vidéo
        const videoUpload = document.getElementById('videoUpload');
        const uploadedVideo = document.getElementById('uploadedVideo');

        videoUpload.addEventListener('change', (event) => {
            const file = event.target.files[0];
            videoFileName = file.name; // Mettre à jour le nom de la vidéo
            const url = URL.createObjectURL(file);
            uploadedVideo.src = url;

            uploadedVideo.onloadeddata = () => {
                uploadedVideo.play();
                canvasElement.width = uploadedVideo.videoWidth;
                canvasElement.height = uploadedVideo.videoHeight;
                processVideo(uploadedVideo);
            };
        });

        async function processVideo(video) {
            while (!video.paused && !video.ended) {
                await holistic.send({image: video});
                await new Promise(requestAnimationFrame);
            }
        }

        // Ajouter l'événement au bouton de téléchargement des logs
        document.getElementById('downloadLogs').addEventListener('click', downloadLogs);
    </script>
</body>
</html>
